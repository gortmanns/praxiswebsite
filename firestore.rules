/**
 * @fileoverview Firestore Security Rules for Prototyping.
 *
 * Core Philosophy:
 * This ruleset prioritizes security by enforcing strict user-ownership and
 * explicit access control while remaining flexible on data schemas to allow
 * for rapid prototyping. Data validation is minimized to focus on
 * authorization.
 *
 * Data Structure:
 * - /users/{userId}: Stores user profile information. Access is restricted to the
 *   user themselves.
 * - /holidays/{holidayId}: Stores holiday periods for the practice. Publicly
 *   readable, but only writeable by an admin (not implemented in this prototype).
 * - /doctors/{doctorId}: Stores information about doctors. Publicly readable,
 *   but only writeable by an admin (not implemented in this prototype).
 *
 * Key Security Decisions:
 * - User listing is disallowed.
 * - Read-only collections (holidays, doctors) are explicitly marked as such.
 * - Ambiguous relationships default to the most secure interpretation (owner-only).
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Manages user profile information.
     * @path /users/{userId}
     * @allow (create) - User with uid 'user123' can create their profile.
     *   Request: { "auth": { "uid": "user123" }, "resource": { "data": { "uid": "user123", "email": "test@example.com" } } }
     * @allow (get) - User with uid 'user123' can read their profile.
     *   Request: { "auth": { "uid": "user123" } }
     * @allow (update) - User with uid 'user123' can update their profile.
     *   Request: { "auth": { "uid": "user123" } }
     * @allow (delete) - User with uid 'user123' can delete their profile.
     *   Request: { "auth": { "uid": "user123" } }
     * @deny (create) - User with uid 'user456' cannot create a profile for 'user123'.
     *   Request: { "auth": { "uid": "user456" }, "resource": { "data": { "uid": "user123" } } }
     * @principle Enforces document ownership for all operations.
     */
    match /users/{userId} {
      allow get: if isSignedIn() && isOwner(userId);
      allow list: if false;
      allow create: if isSignedIn() && isOwner(userId) && request.resource.data.uid == userId;
      allow update: if isSignedIn() && isExistingOwner(userId) && request.resource.data.uid == resource.data.uid;
      allow delete: if isSignedIn() && isExistingOwner(userId);
    }

    /**
     * @description Manages holiday periods for the practice. Publicly readable, owner-only writeable.
     * @path /holidays/{holidayId}
     * @allow (get) - Any user can read holiday information.
     *   Request: { "auth": { "uid": "user123" } }
     * @allow (list) - Any user can list holiday information.
     *   Request: { "auth": { "uid": "user123" } }
     * @deny (create) - Regular user cannot create a holiday (admin-only).
     *   Request: { "auth": { "uid": "user123" } }
     * @principle Public read, owner-only writes (though owner is not yet defined).
     */
    match /holidays/{holidayId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

      /**
       * @description Manages doctor information. Publicly readable, owner-only writeable.
       * @path /doctors/{doctorId}
       * @allow (get) - Any user can read doctor information.
       *   Request: { "auth": { "uid": "user123" } }
       * @allow (list) - Any user can list doctor information.
       *    Request: { "auth": { "uid": "user123" } }
       * @deny (create) - Regular user cannot create a doctor (admin-only).
       *   Request: { "auth": { "uid": "user123" } }
       * @principle Public read, owner-only writes (though owner is not yet defined).
       */
    match /doctors/{doctorId} {
        allow get, list: if true;
        allow create, update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }
  }

  // Helper functions
  function isSignedIn() {
    return request.auth != null;
  }

  function isOwner(userId) {
    return request.auth.uid == userId;
  }

  function isExistingOwner(userId) {
    return isOwner(userId) && resource != null;
  }
}